<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VR Training Simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
  margin: 0;
  overflow: hidden;
  background: #050505;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  color: #00ffcc;
}
canvas { display: block; }

#overlay {
  position: fixed;
  top: 40px;
  width: 100%;
  text-align: center;
  pointer-events: none;
  text-transform: uppercase;
  letter-spacing: 4px;
  text-shadow: 0 0 10px #00ffcc;
}

#loading {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: black;
  z-index: 100;
}
</style>
</head>

<body>

<div id="loading">INITIALIZING NEURAL LINK...</div>
<div id="overlay"><h1>Training Phase 01</h1></div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

/* ───────── SETTINGS ───────── */
const TEXTS = ["ANALYZING...", "STABILIZING...", "SYNCING DATA...", "UPLOADING...", "CORE ACTIVE"];
const BOX_SIZE = 100;
const TEXT_SPEED = 0.4;

/* ───────── CORE SETUP ───────── */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 10, 150);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 20; // Positioned just outside the box opening

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ───────── THE "TRAINING BOX" ───────── */
// We create the walls of the box to give the "looking in" feel
const gridColor = 0x004444;
const boxGroup = new THREE.Group();

const wallMat = new THREE.MeshBasicMaterial({ 
    color: 0x00ffcc, 
    wireframe: true, 
    transparent: true, 
    opacity: 0.1 
});

// Create floor, ceiling, and side walls
const wallGeom = new THREE.PlaneGeometry(BOX_SIZE, BOX_SIZE);

const floor = new THREE.Mesh(wallGeom, wallMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -BOX_SIZE/4;
boxGroup.add(floor);

const ceiling = new THREE.Mesh(wallGeom, wallMat);
ceiling.rotation.x = Math.PI / 2;
ceiling.position.y = BOX_SIZE/4;
boxGroup.add(ceiling);

const leftWall = new THREE.Mesh(wallGeom, wallMat);
leftWall.rotation.y = Math.PI / 2;
leftWall.position.x = -BOX_SIZE/2;
boxGroup.add(leftWall);

const rightWall = new THREE.Mesh(wallGeom, wallMat);
rightWall.rotation.y = -Math.PI / 2;
rightWall.position.x = BOX_SIZE/2;
boxGroup.add(rightWall);

const backWall = new THREE.Mesh(wallGeom, wallMat);
backWall.position.z = -BOX_SIZE/2;
boxGroup.add(backWall);

scene.add(boxGroup);

/* ───────── MOVING TEXT SYSTEM ───────── */
const textElements = [];

function createTextTexture(text) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 512;
    canvas.height = 128;
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, 512, 128);
    ctx.font = 'Bold 40px Arial';
    ctx.fillStyle = '#00ffcc';
    ctx.textAlign = 'center';
    ctx.fillText(text, 256, 64);
    
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(15, 4, 1);
    return sprite;
}

// Spawn initial text meshes
function spawnText() {
    const str = TEXTS[Math.floor(Math.random() * TEXTS.length)];
    const sprite = createTextTexture(str);
    sprite.position.set(
        (Math.random() - 0.5) * 20,
        (Math.random() - 0.5) * 10,
        -80 // Start deep in the box
    );
    scene.add(sprite);
    textElements.push(sprite);
}

// Spawn new text every 2 seconds
setInterval(spawnText, 2000);

/* ───────── LIGHTING ───────── */
const light = new THREE.PointLight(0x00ffcc, 10, 100);
light.position.set(0, 0, 10);
scene.add(light);

/* ───────── ASSET LOADING ───────── */
let model;
const loader = new GLTFLoader();
// Using a placeholder box if model.glb isn't present
const geometry = new THREE.IcosahedronGeometry(5, 0);
const material = new THREE.MeshPhongMaterial({ color: 0x00ffcc, wireframe: true });
model = new THREE.Mesh(geometry, material);
model.position.z = -20;
scene.add(model);

document.getElementById("loading").style.display = "none";

/* ───────── ANIMATION LOOP ───────── */
function animate() {
  requestAnimationFrame(animate);

  // Rotate the center model
  if (model) {
      model.rotation.y += 0.01;
      model.rotation.x += 0.005;
  }

  // Move text toward camera
  for (let i = textElements.length - 1; i >= 0; i--) {
      const t = textElements[i];
      t.position.z += TEXT_SPEED;
      
      // Fade text in as it approaches, then out
      t.material.opacity = Math.min(1, (80 + t.position.z) / 20); 

      // Remove text if it passes camera
      if (t.position.z > 25) {
          scene.remove(t);
          textElements.splice(i, 1);
      }
  }

  // Subtle "breathing" effect for the box
  boxGroup.scale.setScalar(1 + Math.sin(Date.now() * 0.001) * 0.02);

  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
